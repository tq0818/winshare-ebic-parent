<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
   http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd
   http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd
   http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd">
	
	<description>Spring Configuration</description>
	
	<context:property-placeholder ignore-unresolvable="true" location="classpath:winshare.properties" />
	
	<!-- 缓存配置 -->
	<bean id="ehcacheManager" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean">
		<property name="configLocation" value="classpath:cache/ehcache-local.xml" />
	</bean>
	
    <bean id="springCacheManager" class="org.springframework.cache.ehcache.EhCacheCacheManager">
        <property name="cacheManager" ref="ehcacheManager"/>
	</bean>
	
	<bean id="springContextHolder" class="com.winshare.edu.common.utils.SpringContextHolder"></bean>
	
	<!-- 使用Annotation自动注册Bean，解决事物失效问题：在主容器中不扫描@Controller注解，在SpringMvc中只扫描@Controller注解。  -->
	<context:component-scan base-package="com.winshare.edu.modules"><!-- base-package 如果多个，用“,”分隔 -->
		<context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
	</context:component-scan>
	
	<!-- 基于Druid数据库链接池的数据源配置 -->
	<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"
		init-method="init" destroy-method="close">
		<!-- 基本属性driverClassName、 url、user、password -->
		<property name="driverClassName" value="${jdbc.driverClassName}" />
		<property name="url" value="${user.jdbc.url}" />
		<property name="username" value="${user.jdbc.username}" />
		<property name="password" value="${user.jdbc.password}" />

		<!-- 配置初始化大小、最小、最大 -->
		<!-- 通常来说，只需要修改initialSize、minIdle、maxActive -->
		<!-- 初始化时建立物理连接的个数，缺省值为0 -->
		<property name="initialSize" value="2" />
		<!-- 最小连接池数量 -->
		<property name="minIdle" value="2" />
		<!-- 最大连接池数量，缺省值为8 -->
		<property name="maxActive" value="10" />

		<!-- 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 -->
		<property name="maxWait" value="60000" />

		<!-- 有些数据库连接的时候有超时限制（MySQL连接在8小时后断开），或者由于网络中断等原因，连接池的连接会出现失效的情况，这时候可以设置一个testWhileIdle参数为true， 
			如果检测到当前连接不活跃的时间超过了timeBetweenEvictionRunsMillis，则去手动检测一下当前连接的有效性，在保证确实有效后才加以使用。 
			在检测活跃性时，如果当前的活跃时间大于minEvictableIdleTimeMillis，则认为需要关闭当前连接。当 然，为了保证绝对的可用性，你也可以使用testOnBorrow为true（即在每次获取Connection对象时都检测其可用性），不过这样会影响性能。 -->
		<!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒（3600000:为1小时） -->
		<property name="timeBetweenEvictionRunsMillis" value="3600000" />

		<!-- 配置一个连接在池中最小生存的时间，单位是毫秒(300000:为5分钟) -->
		<property name="minEvictableIdleTimeMillis" value="300000" />
		<!-- 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 -->
		<property name="validationQuery" value="${jdbc.pool.validationQuery}" />
		<!-- 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。建议配置为true，不影响性能，并且保证安全性。 -->
		<property name="testWhileIdle" value="true" />
		<!-- 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。缺省值:true -->
		<property name="testOnBorrow" value="false" />
		<!-- 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。缺省值:false -->
		<property name="testOnReturn" value="false" />
	</bean>


	<!-- 将数据源映射到sqlSessionFactory中 -->
    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <property name="dataSource" ref="dataSource"/>
        <property name="mapperLocations">
            <array>
                <value>classpath:mybatis/mapper/*.xml</value>
            </array>
        </property>
        <property name="typeAliasesPackage" value="com.winshare.edu.modules.*.entity"/>
        <property name="plugins">
            <array>
                <bean class="com.github.pagehelper.PageInterceptor">
                    <!-- 这里的几个配置主要演示如何使用，如果不理解，一定要去掉下面的配置 -->
                    <property name="properties">
                        <value>
                            helperDialect=mysql
                            reasonable=true
                            supportMethodsArguments=true
                            params=count=countSql
                            autoRuntimeDialect=true
                        </value>
                    </property>
                </bean>
            </array>
        </property>
	</bean>

    <bean class="tk.mybatis.spring.mapper.MapperScannerConfigurer">
        <property name="basePackage" value="com.winshare.edu.modules"/>
	</bean>

	<!--======= 事务配置 Begin ================= -->
	<!-- 事务管理器（由Spring管理MyBatis的事务） -->
	<bean id="transactionManager"
		class="org.springframework.jdbc.datasource.DataSourceTransactionManager"  >
		<!-- 关联数据源 -->
		<property name="dataSource" ref="dataSource"></property>
	</bean>
	<!-- 注解事务 -->
	<tx:annotation-driven transaction-manager="transactionManager" />

	<aop:aspectj-autoproxy proxy-target-class="true" />

	<!-- 拦截器方式配置事物 -->
	<tx:advice id="transactionAdvice" transaction-manager="transactionManager">
		<tx:attributes>
			<tx:method name="add*" propagation="REQUIRED" />
			<tx:method name="append*" propagation="REQUIRED" />
			<tx:method name="insert*" propagation="REQUIRED"  />
			<tx:method name="save*" propagation="REQUIRED"  rollback-for="java.lang.Exception" />
			<tx:method name="update*" propagation="REQUIRED" />
			<tx:method name="modify*" propagation="REQUIRED" />
			<tx:method name="edit*" propagation="REQUIRED" />
			<tx:method name="delete*" propagation="REQUIRED" />
			<tx:method name="remove*" propagation="REQUIRED" />
			<tx:method name="repair" propagation="REQUIRED" />
			<tx:method name="delAndRepair" propagation="REQUIRED" />
			<tx:method name="changeStatus" propagation="REQUIRED" />
            
			<tx:method name="get*" propagation="SUPPORTS" />
			<tx:method name="find*" propagation="SUPPORTS" />
			<tx:method name="load*" propagation="SUPPORTS" />
			<tx:method name="search*" propagation="SUPPORTS" />
			<tx:method name="datagrid*" propagation="SUPPORTS" />

			<tx:method name="*" propagation="SUPPORTS" />
		</tx:attributes>
	</tx:advice>
	<aop:config>
		<aop:pointcut id="transactionPointcut"
			expression="execution(* com.winshare.edu.modules.*.service.*Service.*(..))" />
		<aop:advisor pointcut-ref="transactionPointcut" advice-ref="transactionAdvice" />
	</aop:config>
	<!--======= 事务配置 End =================== -->

	<!-- 配置druid监控spring jdbc -->
	<bean id="druid-stat-interceptor"
		class="com.alibaba.druid.support.spring.stat.DruidStatInterceptor">
	</bean>
	<bean id="druid-stat-pointcut" class="org.springframework.aop.support.JdkRegexpMethodPointcut"
		scope="prototype">
		<property name="patterns">
			<list>
				<value>com.winshare.edu.modules.*.service.*</value>
			</list>
		</property>
	</bean>
	<aop:config>
		<aop:advisor advice-ref="druid-stat-interceptor" pointcut-ref="druid-stat-pointcut" />
	</aop:config>	
	
	<bean id="orgContractJob" class="com.winshare.edu.modules.classes.job.OrgContractJob">
	   <property name="orgPowerService" ref="orgPowerService" ></property>
	   <property name="orgInfoService" ref="orgInfoService" ></property>
	</bean>
	
	<bean id="orgContractJobTask" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean">
            <property name="targetObject">
                <ref bean="orgContractJob"/>
            </property>
            
            <property name="targetMethod">
                <value>work</value>
            </property>
            <property name="concurrent">
             <value>false</value>
            </property>
        </bean>
    
     <!-- 定义触发时间 -->
        <bean id="orgContractDoTime" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean">
            <property name="jobDetail">
                <ref bean="orgContractJobTask"/>
             </property>
            <!-- cron表达式 -->
            <property name="cronExpression">
                <value>0 * * * * ?</value>
            </property>
        </bean>
        
        
        
        <!-- 总管理类 如果将lazy-init='false'那么容器启动就会执行调度程序  -->
        <bean id="startQuertz" lazy-init="false" autowire="no" class="org.springframework.scheduling.quartz.SchedulerFactoryBean">
            <property name="triggers">
                <list>
                    <ref bean="orgContractDoTime"/>
                </list>
            </property>
        </bean>
</beans>